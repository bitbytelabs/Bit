name: Fix js/remote-property-injection

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["CodeQL"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write

jobs:
  fix:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Only download SARIF if triggered from CodeQL
      - name: Download CodeQL SARIF
        if: github.event_name == 'workflow_run'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id,
            });

            const sarif = artifacts.data.artifacts.find(a => a.name.includes("codeql"));
            if (!sarif) {
              console.log("No SARIF artifact found.");
              return;
            }

            const download = await github.rest.actions.downloadArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: sarif.id,
              archive_format: 'zip'
            });

            fs.writeFileSync('sarif.zip', Buffer.from(download.data));

      - name: Extract SARIF
        if: github.event_name == 'workflow_run'
        run: unzip sarif.zip || true

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Babel
        run: npm install @babel/parser @babel/traverse @babel/generator @babel/types

      - name: Create Fix Script
        run: |
          cat << 'EOF' > fix.js
          const fs = require("fs");
          const parser = require("@babel/parser");
          const traverse = require("@babel/traverse").default;
          const generate = require("@babel/generator").default;
          const t = require("@babel/types");

          function getAllCandidateFiles(rootDir = ".") {
            const ignored = new Set([".git", "node_modules"]);
            const exts = new Set([".js", ".mjs", ".cjs", ".ts", ".tsx", ".jsx"]);
            const out = [];

            function walk(dir) {
              for (const name of fs.readdirSync(dir)) {
                if (ignored.has(name)) continue;
                const full = `${dir}/${name}`;
                const stat = fs.statSync(full);
                if (stat.isDirectory()) {
                  walk(full);
                  continue;
                }
                const ext = name.slice(name.lastIndexOf('.'));
                if (exts.has(ext)) out.push(full.replace(/^\.\//, ""));
              }
            }

            walk(rootDir);
            return out;
          }

          function getFlaggedFiles() {
            const sarifFile = fs.readdirSync(".").find(f => f.endsWith(".sarif"));
            if (!sarifFile) {
              const all = getAllCandidateFiles();
              console.log(`No SARIF found. Manual mode scanning ${all.length} source files.`);
              return all;
            }

            const sarif = JSON.parse(fs.readFileSync(sarifFile, "utf8"));
            const files = new Set();

            for (const run of sarif.runs || []) {
              for (const result of run.results || []) {
                if (result.ruleId === "js/remote-property-injection") {
                  const uri = result.locations?.[0]?.physicalLocation?.artifactLocation?.uri;
                  if (uri) files.add(uri);
                }
              }
            }

            if (files.size === 0) {
              const all = getAllCandidateFiles();
              console.log(`SARIF had no js/remote-property-injection results. Manual mode scanning ${all.length} source files.`);
              return all;
            }

            return [...files];
          }

          function injectValidator(ast) {
            let exists = false;
            traverse(ast, {
              FunctionDeclaration(path) {
                if (path.node.id?.name === "isSafeKey") exists = true;
              }
            });

            if (!exists) {
              const validator = parser.parse(`
                function isSafeKey(key) {
                  if (typeof key !== "string") return false;
                  const blocked = ["__proto__", "prototype", "constructor"];
                  if (blocked.includes(key)) return false;
                  return /^[a-zA-Z0-9_]+$/.test(key);
                }
              `);

              ast.program.body.unshift(...validator.program.body);
            }
          }

          function fixFile(file) {
            if (!fs.existsSync(file)) return;

            const code = fs.readFileSync(file, "utf8");

            let ast;
            try {
              ast = parser.parse(code, {
                sourceType: "unambiguous",
                plugins: ["typescript", "jsx"]
              });
            } catch {
              console.log("Skipped (parse error):", file);
              return;
            }

            let modified = false;

            traverse(ast, {
              AssignmentExpression(path) {
                if (
                  t.isMemberExpression(path.node.left) &&
                  path.node.left.computed &&
                  path.parentPath?.isExpressionStatement()
                ) {
                  const obj = path.node.left.object;
                  const prop = path.node.left.property;
                  const value = path.node.right;

                  const wrapped = t.ifStatement(
                    t.callExpression(t.identifier("isSafeKey"), [prop]),
                    t.blockStatement([
                      t.expressionStatement(
                        t.assignmentExpression(
                          "=",
                          t.memberExpression(obj, prop, true),
                          value
                        )
                      )
                    ])
                  );

                  path.parentPath.replaceWith(wrapped);
                  path.skip();
                  modified = true;
                }
              }
            });

            if (modified) {
              injectValidator(ast);
              const output = generate(ast, {}, code);
              fs.writeFileSync(file, output.code);
              console.log("Fixed:", file);
            }
          }

          const files = getFlaggedFiles();

          if (files.length === 0) {
            console.log("No flagged files found.");
            process.exit(0);
          }

          files.forEach(fixFile);

          console.log("Finished.");
          EOF

      - name: Run Fixer
        run: node fix.js

      - name: Create PR
        uses: peter-evans/create-pull-request@v6
        with:
          base: ${{ github.event.repository.default_branch }}
          branch: security/fix-remote-property
          commit-message: "fix: js/remote-property-injection"
          title: "fix: js/remote-property-injection"
          body: |
            Automatically fixes CodeQL rule:
            js/remote-property-injection
