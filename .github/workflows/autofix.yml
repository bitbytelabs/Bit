name: Fix js/remote-property-injection

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["CodeQL"]
    types:
      - completed

permissions:
  contents: write
  pull-requests: write

jobs:
  fix:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Download CodeQL SARIF
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id,
            });

            const sarif = artifacts.data.artifacts.find(a => a.name.includes("codeql"));
            if (!sarif) return;

            const download = await github.rest.actions.downloadArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: sarif.id,
              archive_format: 'zip'
            });

            fs.writeFileSync('sarif.zip', Buffer.from(download.data));

      - name: Extract SARIF
        run: |
          unzip sarif.zip || true

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Babel
        run: npm install @babel/parser @babel/traverse @babel/generator @babel/types

      - name: Patch Only Flagged Files
        run: |
          cat << 'EOF' > fix.js
          const fs = require("fs");
          const parser = require("@babel/parser");
          const traverse = require("@babel/traverse").default;
          const generate = require("@babel/generator").default;
          const t = require("@babel/types");

          const sarifFile = fs.readdirSync(".").find(f => f.endsWith(".sarif"));
          if (!sarifFile) {
            console.log("No SARIF file found.");
            process.exit(0);
          }

          const sarif = JSON.parse(fs.readFileSync(sarifFile, "utf8"));

          const flaggedFiles = new Set();

          for (const run of sarif.runs) {
            for (const result of run.results || []) {
              if (result.ruleId === "js/remote-property-injection") {
                const location = result.locations?.[0]?.physicalLocation?.artifactLocation?.uri;
                if (location) flaggedFiles.add(location);
              }
            }
          }

          if (flaggedFiles.size === 0) {
            console.log("No remote property injection issues found.");
            process.exit(0);
          }

          function injectValidator(ast) {
            let exists = false;
            traverse(ast, {
              FunctionDeclaration(path) {
                if (path.node.id?.name === "isSafeKey") exists = true;
              }
            });

            if (!exists) {
              const validator = parser.parse(`
                function isSafeKey(key) {
                  if (typeof key !== "string") return false;
                  const blocked = ["__proto__", "prototype", "constructor"];
                  if (blocked.includes(key)) return false;
                  return /^[a-zA-Z0-9_]+$/.test(key);
                }
              `);
              ast.program.body.unshift(...validator.program.body);
            }
          }

          for (const file of flaggedFiles) {
            if (!fs.existsSync(file)) continue;

            const code = fs.readFileSync(file, "utf8");

            let ast;
            try {
              ast = parser.parse(code, {
                sourceType: "unambiguous",
                plugins: ["typescript", "jsx"]
              });
            } catch {
              console.log("Skipped (parse error):", file);
              continue;
            }

            let modified = false;

            traverse(ast, {
              AssignmentExpression(path) {
                if (
                  t.isMemberExpression(path.node.left) &&
                  path.node.left.computed
                ) {
                  const obj = path.node.left.object;
                  const prop = path.node.left.property;
                  const value = path.node.right;

                  const wrapped = t.ifStatement(
                    t.callExpression(t.identifier("isSafeKey"), [prop]),
                    t.blockStatement([
                      t.expressionStatement(
                        t.assignmentExpression(
                          "=",
                          t.memberExpression(obj, prop, true),
                          value
                        )
                      )
                    ])
                  );

                  path.replaceWith(wrapped);
                  path.skip();
                  modified = true;
                }
              }
            });

            if (modified) {
              injectValidator(ast);
              const output = generate(ast, {}, code);
              fs.writeFileSync(file, output.code);
              console.log("Fixed:", file);
            }
          }

          console.log("Finished.");
          EOF

          node fix.js

      - name: Commit & PR
        run: |
          git config user.name "security-bot"
          git config user.email "security-bot@users.noreply.github.com"

          if [[ -n $(git status --porcelain) ]]; then
            git checkout -b security/fix-remote-property
            git add .
            git commit -m "Fix js/remote-property-injection"
            git push origin security/fix-remote-property
          else
            echo "No changes to commit."
          fi

      - uses: peter-evans/create-pull-request@v6
        with:
          branch: security/fix-remote-property
          title: "Fix js/remote-property-injection"
          body: |
            Automatically fixes CodeQL js/remote-property-injection findings.
