const fs = require("fs");
const path = require("path");
const parser = require("@babel/parser");
const traverse = require("@babel/traverse").default;
const generate = require("@babel/generator").default;
const t = require("@babel/types");

function isJS(file) {
  return /\.(js|ts|jsx|tsx)$/.test(file);
}

function walk(dir) {
  let results = [];
  fs.readdirSync(dir).forEach(file => {
    const full = path.join(dir, file);
    if (fs.statSync(full).isDirectory()) {
      if (!full.includes("node_modules"))
        results = results.concat(walk(full));
    } else if (isJS(full)) {
      results.push(full);
    }
  });
  return results;
}

function fixFile(file) {
  const code = fs.readFileSync(file, "utf8");
  const ast = parser.parse(code, {
    sourceType: "unambiguous",
    plugins: ["typescript", "jsx"]
  });

  let modified = false;

  traverse(ast, {
    AssignmentExpression(path) {
      // Skip if already processed
      if (path.node.__secureProcessed) return;

      if (
        t.isMemberExpression(path.node.left) &&
        path.node.left.computed
      ) {
        const obj = path.node.left.object;
        const prop = path.node.left.property;
        const right = path.node.right;

        const newAssign = t.assignmentExpression(
          "=",
          t.memberExpression(obj, prop, true),
          right
        );
        newAssign.__secureProcessed = true;

        const safeIf = t.ifStatement(
          t.callExpression(t.identifier("isSafeKey"), [prop]),
          t.blockStatement([
            t.expressionStatement(newAssign)
          ]),
          t.blockStatement([
            t.throwStatement(
              t.newExpression(t.identifier("Error"), [
                t.stringLiteral("Unsafe property key detected")
              ])
            )
          ])
        );

        path.replaceWith(safeIf);
        path.skip(); // ðŸ”¥ prevents recursive traversal
        modified = true;
      }
    }
  });

  if (modified) {
    injectValidator(ast);
    const output = generate(ast, {}, code);
    fs.writeFileSync(file, output.code);
    console.log("Secured:", file);
  }
}

function injectValidator(ast) {
  let exists = false;

  traverse(ast, {
    FunctionDeclaration(path) {
      if (path.node.id.name === "isSafeKey") {
        exists = true;
      }
    }
  });

  if (!exists) {
    const validator = parser.parse(`
      function isSafeKey(key) {
        if (typeof key !== "string") return false;
        const blocked = ["__proto__", "prototype", "constructor"];
        if (blocked.includes(key)) return false;
        return /^[a-zA-Z0-9_]+$/.test(key);
      }
    `);
    ast.program.body.unshift(...validator.program.body);
  }
}

const files = walk(".");
files.forEach(fixFile);
